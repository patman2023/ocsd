// ==UserScript==
// @name         Tabbed Names
// @description  Renames only the active "Create New Transactions" tab to the visible User value. Per-tab memory. Shadow DOM safe. No duplicate text.
// @version      1.0.6
// @match        https://ocsheriff.servicenowservices.com/x/g/loaner-workspace/*
// @match        https://ocsheriff.servicenowservices.com/now/*
// @run-at       document-idle
// @noframes
// @grant        none
// ==/UserScript==

(function () {
  "use strict";

  const BASE = "Create New Transactions";

  // ---- deep DOM helpers (shadow DOM + same-origin iframes) ----
  const docs = () => {
    const all = [document];
    for (const f of document.querySelectorAll("iframe")) {
      try {
        const d = f.contentDocument || f.contentWindow?.document;
        if (d) all.push(d);
      } catch (_) {}
    }
    return all;
  };

  const deepQueryAllIn = (root, sel) => {
    const out = [];
    const walk = (n) => {
      if (!n) return;
      if (n.querySelectorAll) n.querySelectorAll(sel).forEach((el) => out.push(el));
      const tw = (n.ownerDocument || document).createTreeWalker(n, NodeFilter.SHOW_ELEMENT);
      let cur = n;
      while (cur) { if (cur.shadowRoot) walk(cur.shadowRoot); cur = tw.nextNode(); }
    };
    walk(root);
    return out;
  };

  const deepAll = (sel) => docs().flatMap((d) => deepQueryAllIn(d, sel));

  // ---- tabs ----
  const tabLis = () => deepAll("li.sn-chrome-one-tab-container");
  const tabA = (li) => li.querySelector('a[role="tab"]');
  const tabId = (li) => tabA(li)?.id || null;
  const isActive = (li) => {
    const a = tabA(li);
    return li.classList.contains("is-selected") || a?.getAttribute("aria-selected") === "true";
  };

  // Only write to the actual label span (prevents duplicate text)
  const labelSpan = (li) => li.querySelector("span.sn-chrome-one-tab-label");

  // Scrub stray text nodes in wrappers so they canâ€™t render duplicates
  const scrubOtherWrappers = (li) => {
    const keep = labelSpan(li);
    li.querySelectorAll(".sn-chrome-one-tab-content").forEach((w) => {
      if (keep && (keep === w || w.contains(keep))) return;
      Array.from(w.childNodes).forEach((n) => {
        if (n.nodeType === Node.TEXT_NODE) n.nodeValue = "";
      });
    });
  };

  // Find the **visible** "User" input in the active view
  const USER_SELECTORS = [
    '#form-field-vkl34b2v2hb2-5976',
    'input.now-typeahead-native-input[aria-label="User"][name="user_input"]',
    'input[role="combobox"][aria-label="User"]',
  ];

  const isVisible = (el) => {
    if (!el || !el.isConnected) return false;
    const cs = getComputedStyle(el);
    if (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0") return false;
    return !!(el.offsetParent || el.getClientRects().length);
  };

  const findVisibleUserInput = () => {
    for (const sel of USER_SELECTORS) {
      const el = deepAll(sel).find(isVisible);
      if (el) return el;
    }
    return deepAll('input[type="text"], input[role="combobox"]').find(isVisible) || null;
  };

  // Per-tab label store by tab id
  const store = new Map(); // id -> label

  const setTabLabel = (li, raw) => {
    const txt = (raw && raw.trim()) || BASE;
    const span = labelSpan(li);
    if (span) span.textContent = txt;
    scrubOtherWrappers(li);

    const a = tabA(li);
    if (a) { a.title = txt; a.setAttribute("aria-label", txt); }
    const closeBtn = li.querySelector(".sn-chrome-one-tab-close");
    if (closeBtn) {
      closeBtn.title = `Close Tab ${txt}`;
      closeBtn.setAttribute("aria-label", `Close Tab ${txt}`);
      if (closeBtn.hasAttribute("data-tooltip")) closeBtn.setAttribute("data-tooltip", `Close Tab ${txt}`);
    }
  };

 const apply = () => {
  const lis = tabLis();

  lis.forEach((li) => {
    const id = tabId(li);
    if (!id) return;
    if (!store.has(id)) store.set(id, BASE);
    setTabLabel(li, store.get(id));
  });

  const active = lis.find(isActive);
  if (active) {
    const id = tabId(active);
    const input = findVisibleUserInput();
    const val = (input?.value || input?.textContent || "").trim();
    let text = val || BASE;

    // remove first word if present
    if (val.includes(" ")) {
      const parts = val.split(/\s+/);
      parts.shift();
      text = parts.join(" ") || BASE;
    }

    store.set(id, text);
    setTabLabel(active, text);
  }

  const existing = new Set(lis.map(tabId).filter(Boolean));
  for (const k of Array.from(store.keys())) if (!existing.has(k)) store.delete(k);
};


  apply();

  const mo = new MutationObserver(apply);
  mo.observe(document.documentElement, { childList: true, subtree: true });

  document.addEventListener("click", (e) => {
    if (e.target.closest?.('a[role="tab"], li.sn-chrome-one-tab-container')) setTimeout(apply, 0);
  }, true);

  const end = Date.now() + 60000;
  const t = setInterval(() => { apply(); if (Date.now() > end) clearInterval(t); }, 500);
})();
